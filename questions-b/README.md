# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условные операторы `if`, `switch` (с `break` и fallthrough, включая проблему с инициализацией переменных)
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`
* синтаксис шаблонов, достаточный для написания минимального адаптера `stack<T>` поверх `deque`

## Классы
* определение класса, конструктор, деструктор, методы
* специальные методы (пять штук), правило нуля, правило пяти
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`
* почему `std::move` не выполняет никакого кода

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)

## Исключения
* синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
* раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
* необходимость ловить исключения по ссылке
* exception safety: определения no/basic/strong/nothrow
* умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
* массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

## Многопоточность
* базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
* гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде

# Билеты
## 1x Наследование и классы
`14-210119`, `15-210126`, `16-210202`, `17-210209`, `30-210603`

### 10. Базовое наследование
* Совместимость ссылок и указателей, отличия наследования от `operator Base&()`
* Расположение подобъектов в памяти и padding (пустое место для выравнивания)
* `public`/`private`/`protected` для методов/полей/наследования
* `final` для структур
* Hiding, `using` для методов и конструкторов, изменение видимости полей/методов
* Конструкторы и наследование: отличие от наследования обычных методов
* Слайсинг и как его избежать

### 11. Полиморфные классы
* Виртуальные функции, `override`/`final`, отличия от hiding, вызовы виртуальных функций, таблица виртуальных функций
* Виртуальный деструктор: когда, зачем, что будет, если не сделать
* Вызовы виртуальных функций в конструкторах и деструкторах: обычные, с явным указанием класса через `::`
* `dynamic_cast` для указателей и ссылок, if-init-statement, требование на полиморфность класса
* Эмуляция виртуальных операторов (вроде `operator<<`, практика `14-210121`)
* Виртуальные конструкторы и паттерн "фабричная функция" (в том числе для `make_unique` и копирования)
* RTTI, оператор `typeid`, тип `type_info` и его хранение без `type_index`, `boost::core::demangle`

### 12. Множественное наследование
* Синтаксис, пример
* Возможное представление в памяти, пример изменения адреса при `static_cast` (потому что начало подобъект теперь не всегда совпадает с началом объекта)
* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам
* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа
* Cross-cast
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding

### 13. Виртуальное наследование
* Виртуальный базовый класс: синтаксис, пример
* Порядок инициализации/уничтожения подобъектов и полей, как и где передать параметры конструктором
* Возможное представление в памяти (даже для неполиморфных классов)
* Что происходит, если один класс объявляется и виртуальным, и невиртуальным
* Взаимодействие с `dynamic_cast` при наличии виртуальных методов (работает) и их отсутствии (невозможно)
* Cross-cast
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding

### 14. Использование наследования
* Паттерн "посетитель" (visitor, практика `15-210128`), сравнение с толпой `dynamic_cast` или добавлением виртуальных функций в базовый класс.
* Взаимодействие наследования и шаблонов
* Друзья и наследование + `protected`
* Проблема круга-квадрата и её решения (ограничение интерфейса на чтение/запись, убирание прямого наследования)

### 15. Реализация своего `std::vector`
* Placement new (практика `17-210211`), выравнивание (`alignas`/`alignof`), явный вызов деструктора
* Время жизни объектов (lifetime) и недопустимость операций за пределами lifetime
* Своя реализация `std::optional`
* Своя реализация `std::vector`, трудности с обеспечением базовой гарантии исключений при управлении массивом объектов, трудности при не-`noexcept` перемещении
* Использование `const_cast` для упрощения реализации `vector::at()` (`30-210603`)
* `initializer_list` в конструкторе, в том числе при рекурсивном list initialization

### 16. Type erasure через полиморфные шаблонные классы
Практика `29-210601`

* Своя реализация копируемого `std::any` с `any_cast<>`
* Своя реализация (не)копируемого `std::function<>`

## 2x Исключения
`18-210216`, `19-210302`, `21-210316`

### 20. Исключения — основы
* Предусловия и постусловия конструктора и деструктора, инвариант объекта
* Как отличить "ошибки программирования" (undefined behavior, нарушение инвариантов, невозможно предсказать поведение после) и "ошибки окружения" (некорректный ввод пользователя, теоретически можно предсказать и обработать), разные стратегии обработки для двух видов ошибок.
* Техники обработки ошибок без исключений: `assert`, `exit`, коды возврата (через возвращаемое значение и через аргумент), глобальное состояния, через специальную структуру для возврата.
* Синтаксис `try`/`catch`/`throw`, вложенные `try`/`catch`, несколько `catch` подряд, когда какие исключения ловятся (в том числе с наследованием)
* Слайсинг исключений и как с ним бороться
* Уничтожение локальных (automatic storage) ресурсов (раскрутка стека, stack unwinding)
* Концепция RAII для безопасного владения ресурсами (например, памятью)

### 21. Исключения — детали
* Function-try-block
* Обработка ошибок в конструкторах, деструкторах, исключения в конструкторах и деструкторах и их влияение на время жизни объектов (lifetime)
* Исключения при: создании параметров функции, возврата по значению, конструировании базовых классов и полей, вызове делегированного конструктора; отсутствие `stack::pop()`
* Непойманные исключения и вызов деструкторов
* Производительность исключений в happy path/sad path.

### 22. Гарантии исключений
* Exception safety (безопасность исключений): `noexcept`/no-throw (отсутствия исключений), strong (строгая), basic (базовая), no (отсутствующая)
* Невозможность обеспечения basic guarantee на основе no guarantee
* Обеспечение базовой гарантии при помощи RAII
* Подвохи с базовой гарантией при реализации `operator=(const&)`, если сделать подряд `delete[] data; data = new char[...]` (можно получить UB в деструкторе, чинить — сначала выделить, потом портить поля)
* Особенности при написании шаблонных классов (надо очень аккуратно с гарантиями шаблонного параметра)
* Спецификатор `noexcept`, в том числе условный (`29-210527`), оператор `noexcept`

### 23. Обеспечение гарантий исключений
* Исключения в стандартной библиотеке, в `operator new` и `operator new[]` (включая исключения, вылетающие из конструкторов)
* Базовые классы исключений в стандартной библиотеке: `exception`, `runtime_error`, `logic_error`, проблемы при самостоятельной реализации
* Базовая и строгая гарантия при реализации своего `std::vector`: какие есть компромиссы при реализации между безопасностью и производительностью, как делать
* `catch (...)`
* Перебрасывание текущего исключения при помощи `throw`;
* `exception_ptr`, его создание/использование/хранение, пустое состояние (`27-210513`)

## 3x-4x Совместимость с языком программирования Си
`17-210209`, `19-210302`, `20-210309`, `21-210316`, `22-210323`, `23-210408`, `24-210415`

### 30. Указатели
* Арифметика указателей, one-past-the-last, array-to-pointer decay, арифметика с `void*`
* Указатели на функцию с параметром `void*` как альтернатива функторам
  * Синтаксис, синтаксис, использование, что происходит с перегрузками и шаблонами.
  * Не было: конверсии между указателями.
  * Взятие указателя на перегруженную функцию (`29-210527`)
* C-style-arrays/массивы в стиле Си: инициализация, связь с арифметикой указателей, массивы строк, выделение/освобождение
* Указатели на указатели и глубже: константность и наследование, использование для строк/многомерных массивов двух видов/передачи параметров для возврата
* Тип "массив известного размера", тип "массив неизвестного размера", тип "указатель на массив", `auto`, автовывод размера в шаблонах

### 31. Plain Old Data (POD)
* `reinterpret_cast`, strict aliasing rule и его нарушения, корректное преобразование между `int`/`float` на уровне байт
* Plain Old Data (POD): пример (без строгого определения), использование для (де)сериализации
* Padding (выравнивание) и его отключение, потенциальные проблемы (особенно с не-POD структурами)
* Особенности взятия ссылок и указателей на невыровненную память (пример со `swap` полей)

### 32. Взаимодействие с языком Си
* C-style-strings/ASCIIZ-строки/строки в стиле Си:
  * Определение
  * Способы хранения в структурах (inline и по указателю) и (де)сериализации
  * Отличия `std::string::c_str()` и `std::string::data()`
  * Тип строкового литерала и ссылки на него
  * Выделение/освобождение/конкатенация/получение длины
* `const_cast`
* `extern "C"` и линковка программ на Си/C++, линковка со стандартной библиотекой C++, совместимые между Си/C++ заголовки
* Оборачивание C API в C++ при помощи RAII и исключений.

### 33. Отличия Си и C++
`22-210323`

* Объявления переменных (особенно в C89)
* Объявления своих структур (везде нужно `struct`)
* `(void)` в объявлении функции
* Альтернативы для языковых возможностей: `*_cast<>`, `int a{}`, namespace, ссылки, шаблоны, перегрузка функций и параметры по умолчанию, `bool`, `std::vector`, `using vi = vector<int>`, исключения, anonymous namespace
* Преобразования `void*`

### 34. Особенности Си
* Языковые особенности Си: anonymous union, anonymous struct, designated initializer для структур и массивов, ключевое слово `restrict`
* Идиомы языка Си: макросы для констант и inline-функций, goto для выхода из циклов и обработки ошибок
* Форматы `printf`/`scanf`
* (Не)безопасность `gets`/`sscanf`
* `realloc` и его безопасное использование

## 5x Многопоточность и сети
`25-214022`, `26-210429`, `27-210513`

### 50. TCP-соединения при помощи блокирующего ввод-вывода в Boost::Asio
* Чем характеризуется TCP-соединение: две пары (хост, порт)
* Почему порт сервера обычно фиксирован, а клиента — случаен
* Использование `boost::asio::ip::tcp::iostream` на сервере и на клиенте для создания простого эхо-сервера
* Отличия `local_endpoint()` от `remote_endpoint()`

### 51. Базовая многопоточность
* Создание потоков в C++11, передача аргументов в функцию потока по значению и ссылкам (`28-210520`)
* Joinable/detached потоки
* Гонки: при выводе на экран, по данным, одновременное чтение без записей
* Борьба с гонками: мьютексы, атомарные снимки, RAII-обёртка над мьютексом
* Ключевое слово `mutable`

### 52. Оповещение о событиях
* Условные переменные: как использовать, spurious wakeup
* Реализация producer-consumer
* Реализация `promise`/`future` (без `shared_future`)
* Реализация `latch`

### 53. Дизайн многопоточных приложений
* Deadlock, reentrant-функции, `recursive_mutex`, отделение приватного API без блокировок от публичного API с блокировками
* Взаимные блокировки и их избегание при помощи контроля порядка взятия блокировок или `scoped_lock`/`unique_lock`
* Формализм happens-before, неочевидные примеры нарушения и выполнения
* Частичная потокобезопасность `shared_ptr`

## 6x Метапрограммирование
`27-210513`, `28-210520`, `29-210527`

### 60. Оборачивание кода библиотечным
* `std::reference_wrapper`, `std::ref`, `std::cref`
* Использование perfect forwarding: `std::forward`, когда `T&&` не является forwarding reference
* Теория perfect forwarding: reference collapsing, forwarding reference, во что выводится `T`
* Отличия `ref`/`cref` и perfect forwarding
* `decltype` (два режима работы), `decltype(auto)` для объявления переменных и в возвращаемом типе функций и лямбд, возврат `void`

### 61. Parameter pack — основы
* Функции с произвольным числом аргументов: синтаксис function parameter pack, как выводятся типы, автовывод нескольких template parameter pack из аргументов
* Template parameter pack, variadic template (в том числе специализации — у них может быть несколько паков)
* Pack expansion, в том числе параллельный
* Perfect forwarding для множества параметров функции
* Fold expression (бинарный и унарный), трюк с лямбда-функцией для эмуляции цикла по элементам parameter pack

### 62. Parameter pack — детали
* Возврат parameter pack невозможен, что с этим делать
* Pattern matching + специализации для рекурсивной обработки элементов пака у классов
* Pattern matching + автовывод параметров + перегрузки для обработки элементов пака у функций
* Реализация `std::tuple`, `std::get`, `std::tuple_size`, `std::tuple_element`, `std::make_tuple`
* Трюки с pack expansion: инициализацию массива (в том числе фиктивного до fold expression C++17), `operator,`

### 63. Базовое метапрограммирование и трюки
* Type display trick от Scott Meyers: как проще всего посмотреть тип произвольного выражения?
* Прокси-объекты (вроде `vector<bool>::iterator`)
  * Когда и зачем нужны.
  * Реализация: чтение, запись, `operator[]() const`, самоприсваивание.
  * Проблемы с `auto`, решение через `iterator_traits`
* Спецификатор `noexcept`, в том числе условный (`29-210527`), оператор `noexcept`
* ADL, hidden friends (без шаблонных hidden friend)

### 64. Вычисления на этапе компиляции — основы
* `constexpr`-вычисления: константы, функции
* Функции из типов в типы или значения до C++11 (через шаблоны классов их специализации), конвенции `_t`, `_v`
* Реализация функций из типов куда угодно: наследование классов для упрощения кода, pattern matching для разбора типов
* Стандартные классы `integral_constant` и его наследники

### 65. Вычисления на этапе компиляции — детали
* `iterator_traits<T>`:
  * `::value_type`, отличия от `T::value_type`.
  * Зачем нужен, когда в C++11 есть `auto`.
* Свои расширяемые type traits на примере `serialization_trait<T>` со статическими методами `serialize`/`deserialize`
* Невычислимые контексты: `decltype`, `sizeof`, `noexcept`
* Вспомогательная функция `std::declval<>`, пример внутри `decltype`

### 66. Кортежи
* `tuple<>`, `get<>`, `tuple_size<>`, `tuple_element<>`: использование
* Ссылки внутри `std::tuple`, `std::tie`
* Structured binding: синтаксис, как работает с массивами, кортежеподобными структурами (ADL), простым структурами, проблема с возвратом ссылок (вроде `std::minmax`)
* Реализация своего логгера для вызовов функций (практика `28-210525`)

### 67. Хитрые указатели
* `std::addressof`
* Тип "функция" и "указатель на функцию"
* Указатели на функции: синтаксис, использование, что происходит с перегрузками и шаблонами.
  * Не было: конверсии между указателями.
  * Взятие указателя на перегруженную функцию (`29-210527`)
* Указатели на члены класса (поля, методы) и их вызов (`.*` и `->*`)

### 68. SFINAE
* Определение для функций и специализаций шаблонов, исходное применение
* Отличия hard compilation error от SFINAE, работа внутри псевдонимов типов, примеры неработающего SFINAE
* SFINAE по возвращаемому типа: без запятой, с оператором `,`
* `enable_if`: требования, реализация
* SFINAE+`enable_if` по: возвращаемому типу, специализации шаблона
* SFINAE для удаления методов из шаблонных классов, в том числе нешаблонных

## Явно исключено
* `std::uninitialized_fill`
* tag dispatching
* иерархия итераторов и их виды
* `::operator new`
* аллокаторы
* Невозможность `static_cast` от виртуальной базы к наследнику
* Использование виртуального наследования для ABC (abstract base class)
* `aligned_alloc` и `free` для объектов с большим требованием на выравнивание (25-200414)
* Строгая гарантия исключений: фраза "выполнять операции в две фазы", copy-and-swap trick, проблемы от не-`noexcept` конструктора/оператора перемещения
* SFINAE для конструкторов
