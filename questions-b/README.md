# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете какие-то термины что-то из списка ниже, это автоматический неуд.

## Термины
* Свободная функция, функция-член
* Время жизни объекта: автоматическое, динамическое, статическое
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

## Переменные
* статическая типизация
* тип переменной
* размер переменной, размер типа
* типы <code>int</code>, <code>char</code>: типичные размеры. Например, на архитектуре <code>x86_64</code> под Linux в компиляторе <code>GCC</code>.

## Основные конструкции языков C и C++
* объявления переменных
* выражения и операторы:
  * арифметические (`+`, `-`, `*`, `/`, `%`, `+=`, `-=`, `*=`, `/=`, `%=`, `++`, `--`)
  * булевы (`<`, `<=`, `>`, `>=`, `==`, `!=`, `&&`, `||`, `!`)
  * на минимальную оценку необязательно знать: отличия постфиксных и префиксных операторов
* условные операторы `if`, `switch` (с `break` и fallthrough, включая проблему с инициализацией переменных)
* циклы `for`, `while`

## Функции
* объявление и определение функции, требуется отличать между собой (можно случайно перепутать, но после вопроса исправиться)
* вызов функции (синтаксис, не нужно знать mangling, конвенции вызовов)
* возвращаемое значение
* рекурсивный вызов

## Основные конструкции C++
* синтаксис `static_cast`
* синтаксис объявления пространств имён, обращения к элементу внутри пространства имён
* `auto` для объявления переменных
* range-based for, в том числе с `auto&` и `const auto&`
* синтаксис шаблонов, достаточный для написания минимального адаптера `stack<T>` поверх `deque`

## Классы
* определение класса, конструктор, деструктор, методы
* специальные методы (пять штук), правило нуля, правило пяти
* приватные/защищённые/публичные поля и методы
* наследование: базовый синтаксис, включая вызов конструктора базового класса

## Полиморфные классы
* виртуальные методы и их отличия от невиртуальных
* необходимость виртуального деструктора
* чисто виртуальные функции, что происходит при отсутствии `override` или `virtual`
* slicing (срезка объектов) при присваивании полиморфного класса в переменную типа "базовый класс", как защититься (хранить только ссылки/умные указатели)
* хранение полиморфных объектов в контейнерах
* `dynamic_cast` для полиморфных классов (по указателям и ссылкам)

## Const correctness
* синтаксис константных ссылок, применение при передаче аргументов
* невозможность изменять константные объекты и их поля
* const-qualifier у методов (const member function), перегрузка по const-qualifier (const overloading)

## Использование move-семантики
* эффективная инициализация полей класса из аргументов, принятых по значению или по rvalue-ссылке
* moved-from состояние у объектов: может быть не определено, может быть невозможно обнаружить, пример ошибки
* отсутствие необходимости `move` из результата функции, возвращённого по значению
* необходимость move для явной передачи владения `unique_ptr`
* почему `std::move` не выполняет никакого кода

## STL
* использование `vector` как динамического массива фиксированной длины, <code>push_back</code> и <code>emplace_back</code>
* использование `map` со стандартным компаратором, особенность <code>operator[]</code> (создаёт значение даже при чтении)

## Исключения
* синтаксис `try`/`catch`/`throw`, включая `catch (...)` и `throw;` (но без function-try-block)
* раскрутка стека: автоматический вызов деструкторов, в том числе в `new`/`new[]`, конструкторе, конструкторах полей
* необходимость ловить исключения по ссылке
* exception safety: определения no/basic/strong/nothrow
* умение добавить базовую гарантию в произвольный код при помощи автоматических выполняемых деструкторов

## Си
* использование строк в стиле Си: отличия `char s[10]` и `const char *s`, хранение в структурах, преобразование с `std::string`
* операции со строками в стиле Си: конкатенция, получение длины, безопасная альтернатива для `gets` и `scanf("%s")`
* массивы массивов в языке Си (вроде `int**`): выделение, освобождение, использование

## Многопоточность
* базовое использование `thread` (включая `join()`), `mutex` и `unique_lock`
* гонки: пример гонки данных и гонки при выводе на экран, как избежать, умение видеть гонки в произвольном несложном коде

# Билеты
## 1x Наследование и классы
`14-210119`, `15-210126`, `16-210202`, `17-210209`, `30-210603`

### 10. Базовое наследование
* Совместимость ссылок и указателей, отличия наследования от `operator Base&()`
* Расположение подобъектов в памяти и padding (пустое место для выравнивания)
* `public`/`private`/`protected` для методов/полей/наследования
* `final` для структур
* Hiding, `using` для методов и конструкторов, изменение видимости полей/методов
* Конструкторы и наследование: отличие от наследования обычных методов
* Слайсинг и как его избежать

### 11. Полиморфные классы
* Виртуальные функции, `override`/`final`, отличия от hiding, вызовы виртуальных функций, таблица виртуальных функций
* Виртуальный деструктор: когда, зачем, что будет, если не сделать
* Вызовы виртуальных функций в конструкторах и деструкторах: обычные, с явным указанием класса через `::`
* `dynamic_cast` для указателей и ссылок, if-init-statement, требование на полиморфность класса
* Эмуляция виртуальных операторов (вроде `operator<<`, практика `14-210121`)
* Виртуальные конструкторы и паттерн "фабричная функция" (в том числе для `make_unique` и копирования)
* RTTI, оператор `typeid`, тип `type_info` и его хранение без `type_index`, `boost::core::demangle`

### 12. Множественное наследовани
* Синтаксис, пример
* Возможное представление в памяти, пример изменения адреса при `static_cast` (потому что начало подобъект теперь не всегда совпадает с началом объекта)
* Порядок инициализации/уничтожения подобъектов и полей, как передать параметры конструкторам
* Возможное дублирование базового класса и возникающие неоднозначности при приведении типа
* Cross-cast
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding

### 13. Виртуальное наследование
* Виртуальный базовый класс: синтаксис, пример
* Порядок инициализации/уничтожения подобъектов и полей, как и где передать параметры конструктором
* Возможное представление в памяти (даже для неполиморфных классов)
* Что происходит, если один класс объявляется и виртуальным, и невиртуальным
* Взаимодействие с `dynamic_cast` при наличии виртуальных методов (работает) и их отсутствии (невозможно)
* Cross-cast
* Как теперь работают `dynamic_cast`/`static_cast`/неявное преобразование/`override`/hiding

### 14. Использование наследования
* Паттерн "посетитель" (visitor, практика `15-210128`), сравнение с толпой `dynamic_cast` или добавлением виртуальных функций в базовый класс.
* Взаимодействие наследования и шаблонов
* Друзья и наследование + `protected`
* Проблема круга-квадрата и её решения (ограничение интерфейса на чтение/запись, убирание прямого наследования)

### 15. Реализация своего `std::vector`
* Placement new (практика `17-210211`), выравнивание (`alignas`/`alignof`), явный вызов деструктора
* Время жизни объектов (lifetime) и недопустимость операций за пределами lifetime
* Своя реализация `std::optional`
* Своя реализация `std::vector`, трудности с обработкой исключений при управлении массивом объектов
* Использование `const_cast` для упрощения реализации `vector::at()` (`30-210603`)
* `initializer_list` в конструкторе, в том числе при рекурсивном list initialization

### 16. Type erasure через полиморфные шаблонные классы
Практика `29-210601`

* Своя реализация копируемого `std::any` с `any_cast<>`
* Своя реализация (не)копируемого `std::function<>`

## 2x Исключения
`18-210216`, `19-210302`, `21-210316`

* Техники обработки ошибок: `assert`, `exit`, коды возврата (через возвращаемое значение и через аргумент), глобальное состояния, через специальную структуру для возврата.
* `try`/`catch`/`throw`, когда какой тип ловится (в том числе с наследованием), слайсинг исключений, что происходит с automatic storage duration (раскрутка стека), `catch (...)`
* Непойманные исключения и вызов деструкторов (раскрутка стека)
* Exception safety (безопасность исключений): `noexcept`/no-throw (отсутствия исключений), strong (строгая), basic (базовая), no (отсутствующая)
* Концепция RAII для безопасного владения ресурсами (например, памятью)
* Обработка ошибок в конструкторах, деструкторах, исключения в конструкторах и деструкторах и их влияение на время жизни объектов (lifetime)
* Исключения в стандартной библиотеке, в `operator new` и `operator new[]` (включая исключения, вылетающие из конструкторов)
* Исключения при: создании параметров функции, возврата по значению, конструировании базовых классов и полей, вызове делегированного конструктора; отсутствие `stack::pop()`
* Function-try-block
* Базовая и строгая гарантия при реализации своего `std::vector`: какие есть компромиссы при реализации между безопасностью и производительностью
* Перебрасывание исключений при помощи `throw;`
* Базовые классы исключений в стандартной библиотеке: `exception`, `runtime_error`, `logic_error`, проблемы при самостоятельной реализации
* Спецификатор `noexcept`, в том числе условный (`29-210527`), оператор `noexcept`
* Производительность исключений в happy path/sad path.
* `exception_ptr`, его создание/использование/хранение, пустое состояние (`27-210513`)

## 3x-4x Совместимость с языком программирования Си
`17-210209`, `19-210302`, `20-210309`, `21-210316`, `22-210323`, `23-210408`, `24-210415`

* Арифметика указателей, one-past-the-last, array-to-pointer decay
* Применение `void*`, арифметика с `void*`
* C-style-arrays/массивы в стиле Си: инициализация, связь с арифметикой указателей, массивы строк, выделение/освобождение
* Указатели на указатели и глубеж: константность и наследование, использование для строк/многомерных массивов двух видов/передачи параметров для возврата
* Тип "массив известного размера", тип "массив неизвестного размера", тип "указатель на массив", `auto`, автовывод размера в шаблонах
* `reinterpret_cast`, strict aliasing rule и его нарушения, корректное преобразование между `int`/`float` на уровне байт
* Plain Old Data (POD): пример (без строгого определения), использование для (де)сериализации, padding (выравнивание) и его отключение, особенности взятия ссылок и указателей на невыровненную память (пример со `swap`)
* C-style-strings/ASCIIZ-строки/строки в стиле Си: определение, способы хранения в структурах и (де)сериализации, отличия `std::string::c_str()` и `std::string::data()`, тип строкового литерала и ссылки на него
* `const_cast`
* Отличия от языка Си (`22-210323`): объявления переменных, `(void)` в объявлении функции, альтернативы для языковых возможностей (в том числе anonymous namespace), преобразования с `void*`, альтернатива функторам
* Языковые особенности Си: anonymous union, anonymous struct, designated initializer для структур и массивов, ключевое слово `restrict`
* Идиомы языка Си: макросы для констант и inline-функций, goto для выхода из циклов и обработки ошибок, форматы `printf`/`scanf`, (не)безопасность `gets`/`sscanf`, `realloc` и его безопасное использование
* `extern "C"` и линковка программ на Си/C++, линковка со стандартной библиотекой C++, совместимые между Си/C++ заголовки
* Оборачивание C API в C++ при помощи RAII и исключений.

## 5x Многопоточность и сети
`25-214022`, `26-210429`, `27-210513`

* Использование `boost::asio::ip::tcp::iostream` на сервере и на клиенте, отличия `local_endpoint()` от `remote_endpoint()`
* Создание потоков, передача аргументов в функцию потока, joinable/detached потоки
* Гонки: при выводе на экран, по данным, одновременное чтение
* Борьба с гонками: мьютексы, атомарные снимки, RAII-обёртка над мьютексом
* Ключевое слово `mutable`
* Reentrant-функции, `recursive_mutex`, deadlock, порядок взятие блокировок, избегание взаимных блокировок
* Условные переменные, spurious wakeup, реализация producer-consumer, реализация `promise`/`future` (без `shared_future`), реализация `latch`
* Концепция happens-before, неочевидные примеры нарушения
* Частичная безопасность `shared_ptr`

## 6x Метапрограммирование
`27-210513`, `28-210520`, `29-210527`

* Variadic templates (вариативные шаблоны): параметры функций, параметра шаблонов, fold expression (унарные, бинарные), раскрытие parameter pack, итерирование по аргументам функции, реализация `tuple<>`
  * Отличия `foo(xs...)` от `foo(xs, ...)`
* `tuple<>`, `get<>`, `tuple_size`, `tuple_element`, реализация логгера для вызовов функций (практика `28-210525`)
* Два способа передачи параметров: `ref`/`cref` и perfect forwarding (в том числе теория для universal reference)
* `decltype`, `decltype(auto)` для объявления переменных и в возвращаемом типе функций и лямбд
* Стандартные конвенции: функции на этапе компиляции до C++11, функции, возвращающие тип, `_t`, `_v`, наследование от `std::integral_constant`/`std::bool_constant`
* Свои расширяемые type traits (TODO)
* Спецификатор `noexcept`, в том числе условный (`29-210527`), оператор `noexcept`
* `std::declval<>`
* `std::addressof`
* Указатели на члены класса (поля, методы) и их вызов
* SFINAE: определение для функций и шаблонов, отличия hard compilation error от SFINAE, примеры неработающего SFINAE, примеры работающего (возвращаемое значение с/без запятой), `enable_if` (возвращаемое значение, специализация шаблона, нешаблонный метод в шаблонном классе)

# TODO
## 210112
* `iterator_traits<T>`:
  * `::value_type`, отличия от `T::value_type`.
  * Зачем нужен, когда в C++11 есть `auto`.
* Прокси-объекты (вроде `vector<bool>::iterator`)
  * Когда и зачем нужны.
  * Реализация: чтение, запись, `operator[]() const`, самоприсваивание.
  * Проблемы с `auto`, решение через `iterator_traits`
* Указатели на функции: синтаксис, использование, что происходит с перегрузками и шаблонами.
  * Не было: конверсии между указателями.
  * Взятие указателя на перегруженную функцию (`29-210527`)

## 23-210408
* `switch`/`case`, `break`, `[[fallthrough]]`, объявление переменных внутри `switch`/`case` в языках Си и C++

## 30-210603
* structured binding
* ADL, hidden friends

## Явно исключено
* `std::uninitialized_fill`
* tag dispatching
* иерархия итераторов и их виды
* `::operator new`
* аллокаторы
* Невозможность `static_cast` от виртуальной базы к наследнику
* Использование виртуального наследования для ABC (abstract base class)
* `aligned_alloc` и `free` для объектов с большим требованием на выравнивание (25-200414)
