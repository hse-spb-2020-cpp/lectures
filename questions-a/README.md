# Обязательные знания
Если вы не знаете что-то из списка ниже, это автоматический неуд.

* Термины: свободная функция, функция-член, конструктор, деструктор.
* Почему `std::move` не выполняет никакого кода.
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

# Билеты
## Базовый синтаксис
* Отличия и примерные границы значений встроенных типов ("на контесте"):
  * `int`, `double` (почему `0.1 + 0.2 != 0.3`), `bool`.
  * Знаковость и беззнаковость типов.
* Литералы: целочисленный (и `'` с C++11), вещественный, символ.
* Строковые литералы: обычный, raw string literal, экранирование (escaping).
* Склейка подряд написанных строковых литералов.
* `static_cast<>`: пример избавления от переполнения при умножении `int`'ов.
* Разница между `i++` и `++i`.

* Составные операторы присваивания (compound assignment operator) вроде `*=`, `/=`.
* Expression и statement, что такое тип expression.
* Синтаксис: `for` (включая объявление переменной в `init`), `while`, `if`, где expression и statement.
* Range-based `for`, в том числе с использованием (константных) ссылок и `auto`, где возникают копирования.
* Порядок вычислений: https://notes.algoprog.ru/cpp/additional.html#id4
  * Внутри выражений: аргументы функции, операнды операторов.
  * При инициализации нескольких переменных.
  * При инициализации при помощи `{}`.
  * Что изменилось в C++17, почему в `a = b` важно сначала вычислить `b`, потом `a`.

## Объявление объектов внутри одного файла
* Допустимые имена переменных, функций, констант, классов:
  * Нельзя начинать с цифры.
  * Где посмотреть ключевые слова.
  * Где можно и нельзя ставить `_`: https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
  * Что происходит от некорректного имени в разных случаях.
* Объявление и определение: функции, класса, в том числе шаблонного.
* Взаимная рекурсия для: функций, классов, методов внутри одного класса.
* Пространства имён: глобальное, вложенное, синтаксис для объявления вложенных namespace с C++11.
  * Почему нельзя просто сделать класс со статическими членами?
* Обращение к вложенному namespace, к глобальному namespace.
* Псевдонимы типов: `typedef`, `using`, `template<> using`.
* `using namespace`, где можно и нельзя использовать и почему, особенности `using namespace <другая-библиотека-вроде-std>`.

Тесно связано с: линковка.

## Объявление переменных
* Объявление нескольких переменных, указателей, ссылок, в том числе константных.
* Создание временного объекта.
* C++17: существование Class Template Argument Deduction, пример.
* Отличия copy initialization и direct initialization.
  * Тесно связано с: преобразования (conversions).
* Неинициализированные переменные/поля.
* `[[maybe_unused]]`
* Инициализация при помощи `{}`:
  * Для тривиальных типов.
  * Для нетривиальных типов.
  * Для массивов/векторов, в том числе вложенных.
  * Временных объектов.
* Сложная инициализация при помощи `{}`
* Пример, где инициализация через `{}` и `()` компилируются и ведут себя по-разному.
* Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
  * Использование константных ссылок.
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).
* `auto` и его модификации, как выводится тип.
  * Конвенция Almost Always Auto, в том числе для шаблонных типов.
* Необходимость слова `typename` в некоторых случаях.
* Structured binding для пар, простых структур, массивов, со ссылкой.
  * Не было: как делать для своих структур, что на самом деле происходит внутри, что происходит с временными значениями.

Тесно связно с: параметры функций.

## Функции
* Параметры
  * Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)
  * Передача параметров по: значению, `&`, `const&`, `&&`. Что выбрать при наличии или отсутствии move-семантики и почему.
  * Примеры: `push_back`, `Person(string first_name)`.
  * Передача `{}` в параметры.
* Возвращаемый тип
  * Использование `auto` и `->`, удобство при определении функций-членов
  * Как выводится просто `auto` (возможно, с модификаторами), в том числе для рекурсии и `void`.
* Возвращаемое значение
  * Возврат по значению, ссылке, константной ссылке.
  * Возврат `{}` и взаимодействие с `auto`.
  * `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно
* Перегрузка функций:
  * Что входит в сигнатуру, что не входит.
  * Синтаксис `= delete` с C++11.
  * Проблемы с разделением `nullptr`, `NULL`, `0`.
  * Не было: `noexcept`.
  * Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* Указатели на функции: синтаксис, использование.
  * Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.
