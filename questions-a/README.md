# Общее
* В билете написано почти всё, что надо рассказать.
* Для каждой синтаксической конструкции должен быть приведён содержательный пример, когда это требуется или делает код проще/удобнее.
* Вас могут активно спрашивать вокруг билета: если вы сказали, что надо писать `Foo(bar)`, вас могут сразу же спросить, что будет при написании `Foo(&bar)`, вы должны ответить.
* "Не было" — не было на лекции, знать не надо, не спрашивают. Даже если было на практике.

# Обязательные знания
Если вы не знаете что-то из списка ниже, это автоматический неуд.

* Термины: свободная функция, функция-член, конструктор, деструктор.
* Почему `std::move` не выполняет никакого кода.
* Undefined behavior: что может произойти, примеры:
  * Неинициализированная переменная: почему у неё нет никакого значения.
  * Выход за границы массива.
  * Dangling reference (висячая ссылка) при возврате из функции, при инвалидации в стандартном контейнере.
  * Разыменование `nullptr`.

# Билеты
## Базовый синтаксис
* Отличия и примерные границы значений встроенных типов ("на контесте"):
  * `int`, `double` (почему `0.1 + 0.2 != 0.3`), `bool`.
  * Знаковость и беззнаковость типов.
* Литералы: целочисленный и вещественный (в том числе `10'000` с C++14), символьный.
* Строковые литералы: обычный, raw string literal, экранирование (escaping).
* Склейка подряд написанных строковых литералов.
* `static_cast<>`: пример избавления от переполнения при умножении `int`'ов.
* Разница между `i++` и `++i`.

* Составные операторы присваивания (compound assignment operator) вроде `*=`, `/=`.
* Expression и statement, что такое тип expression.
* Синтаксис: `for` (включая объявление переменной в `init`), `while`, `if`, где expression и statement.
* Range-based `for`, в том числе с использованием (константных) ссылок и `auto`, где возникают копирования.
* Порядок вычислений: https://notes.algoprog.ru/cpp/additional.html#id4
  * Внутри выражений: аргументы функции, операнды операторов.
  * При инициализации нескольких переменных.
  * При инициализации при помощи `{}`.
  * Что изменилось в C++17, почему в `a = b` важно сначала вычислить `b`, потом `a`.

## Объявление объектов внутри одного файла
* Допустимые имена переменных, функций, констант, классов:
  * Нельзя начинать с цифры.
  * Где посмотреть ключевые слова.
  * Где можно и нельзя ставить `_`: https://stackoverflow.com/questions/228783/what-are-the-rules-about-using-an-underscore-in-a-c-identifier
  * Что происходит от некорректного имени в разных случаях.
* Объявление и определение: функции, класса, в том числе шаблонного.
* Взаимная рекурсия для: функций, классов, методов внутри одного класса.
* Пространства имён: глобальное, вложенное, синтаксис для объявления вложенных namespace с C++11.
  * Почему нельзя просто сделать класс со статическими членами?
* Обращение к вложенному namespace, к глобальному namespace.
* Псевдонимы типов: `typedef`, `using`, `template<> using`.
* `using namespace`, где можно и нельзя использовать и почему, особенности `using namespace <другая-библиотека-вроде-std>`.

Тесно связано с: линковка.

## Объявление переменных
* Объявление нескольких переменных, указателей, ссылок, в том числе константных.
* Создание временного объекта.
* C++17: существование Class Template Argument Deduction, пример.
* Отличия copy initialization и direct initialization.
  * Тесно связано с: преобразования (conversions).
* Неинициализированные переменные/поля.
* `[[maybe_unused]]`
* Инициализация при помощи `{}`:
  * Для тривиальных типов.
  * Для нетривиальных типов.
  * Для массивов/векторов, в том числе вложенных.
  * Временных объектов.
* Сложная инициализация при помощи `{}`
* Пример, где инициализация через `{}` и `()` компилируются и ведут себя по-разному.
* Ссылки.
  * Можно ли отличить ссылку от объекта, на который она указывает.
  * Использование константных ссылок.
  * Константная ссылка не обещает, что объект не меняется (если ссылка на мутабельный объект).
* `auto` и его модификации, как выводится тип.
  * Конвенция Almost Always Auto, в том числе для шаблонных типов.
* Необходимость слова `typename` в некоторых случаях.
* Structured binding для пар, простых структур, массивов, со ссылкой.
  * Не было: как делать для своих структур, что на самом деле происходит внутри, что происходит с временными значениями.

Тесно связно с: параметры функций.

## Функции
* Параметры
  * Синтаксис (пропущенное имя, значение по умолчанию в объявлении/определении)
  * Передача параметров по: значению, `&`, `const&`, `&&`. Что выбрать при наличии или отсутствии move-семантики и почему.
  * Примеры: `push_back`, `Person(string first_name)`.
  * Передача `{}` в параметры.
* Возвращаемый тип
  * Использование `auto` и `->`, удобство при определении функций-членов
  * Как выводится просто `auto` (возможно, с модификаторами), в том числе для рекурсии и `void`.
* Возвращаемое значение
  * Возврат по значению, ссылке, константной ссылке.
  * Возврат `{}` и взаимодействие с `auto`.
  * `[[nodiscard]]`, возможные стратегии применения: когда не имеет смысла игнорировать возвращаемое значение, когда игнорировать опасно
* Перегрузка функций:
  * Что входит в сигнатуру, что не входит.
  * Синтаксис `= delete` с C++11.
  * Проблемы с разделением `nullptr`, `NULL`, `0`.
  * Не было: `noexcept`.
  * Не было: правил выбора перегрузки точнее "выбирается перегрузка наиболее точная или ambiguous".
* Указатели на функции: синтаксис, использование.
  * Не было: конверсии между указателями, что происходит с перегрузками.

Тесно связано с: методы.

## Жизнь объектов
* Семантика копирования: что ожидается в C++ при переприсваивании объекта, передаче в качестве аргумента функции, возврата из функции.
  * А если не `Foo a;`, а `Foo &a = .....;`?
* Время жизни объектов (storage): автоматическое (automatic), ручное/динамическое (dynamic), статическое (static).
  * Синтаксис создания/удаления объекта.
  * Когда вызывается конструктор/деструктор и с какими параметрами.
* Время жизни временных объектов.
  * Когда создаётся/уничтожается временный объект ("наивный взгляд" до C++14 включительно).
  * Продление жизни временого объекта.
  * Проблема продления жизни в `std::min()`/`std::max()`.
  * Проблема продления жизни в range-based-for и цепочке вызовов `foo().bar()`.
* Локальные объекты со static storage duration (локальные статические переменные):
  * Когда создаётся/уничтожается.
  * Чем инициализируются, можно ли инициализировать параметром функции.

Тесно связано с: move-семантика.

## Move-семантика
* Категории значений: lvalue/xvalue/prvalue; обобщённые glvalue/rvalue.
  * Определение в C++11/C++14.
  * Определение в C++17 и позже.
* rvalue-ссылки и lvalue-ссылки: что к чему привязывается
* Почему у move constructor и move assignment именно такая сигнатура, как работает разрешение перегрузок, почему не надо добавить `const`.
* `std::move`: как работает, почему ничего не делает, где используется, как реализовать свой.
* Примеры return value optimization, named return value optimization до C++17.
* Guaranteed copy elision в C++17: новый смысл prvalue.
* Возврат объектов:
  * Возврат неперемещаемых объектов из функции.
  * Когда (не) надо писать `return std::move(foo);`

Тесно связано с: функции (как передавать параметры), жизнь объектов.

## Стандартная библиотека
* Что такое `namespace std`.
* Контейнеры
  * `std::vector`, `std::string`, `std::list`: когда что использовать
  * Основные операции и время работы: `push_back`/`emplace_back`, `front()`/`back()`, `operator[]`, `size()`, `capacity()`, `resize()`, `reserve()`.
  * Инвалидация итераторов и ссылок на элементы: когда, какие последствия.
* Итераторы
  * Конвенции с `begin()`/`end()`
  * Не было: иерархия итераторов, `reverse_iterator`.
* Алгоритмы
  * `sort`, передача своего компаратора.
  * `lower_bound`, `upper_bound`, точные инварианты.
* Ввод-вывод
  * `cin`/`cout`/`ifstream`/`ofstream`/`istream`/`ostream`/`sstream`
  * Какие `#include` бывают (2 шт)
  * Синтаксис ввода и вывода.
  * Перегрузка операторов ввода-вывода для своих классов: конвенции, почему так работает, когда нужны friend-операторы и зачем.
  * Не было: манипуляторы, свои манипуляторы.

Тесно связано с: лямбда-функции, базовый синтаксис (порядок вычислений).

## Указатели
* Базовый синтаксис: объявление, разыменование, взятие адреса, `->`.
  * Не было: многоуровневые указатели, aliasing.
* Реализация двусвязного списка, конструкции вроде `a.next->prev`.
* Нулевой указатель.
  * Отличия `nullptr` от `0`
  * Проверка на нулевой указатель.
  * Разменование `nullptr`.
* Ручное управление памятью: `new`, `delete`, `new[]`, `delete[]`, когда что использовать.
  * Не было: разница между `new int;` и `new int();`
  * Утечка памяти: UB ли, какие последствия, как ловить, как читать вывод sanitizer и Valgrind с примерами.

## Классы
* Синтаксис.
* Поля: обычные, константные, ссылки, порядок создание и уничтожения и когда он важен.
* Семантика копирования, особенности полей-констант/ссылок при копировании и инициализации.
* Конструктор: синтаксис, параметры, когда вызывается, делегирующие конструкторы.
* Инициализация полей: когда что можно и нужно использовать, как они взаимодействуют между собой и с делегирующим конструктором
  * По умолчанию (тривальных и с конструктором по умолчанию)
  * Default member initializer (C++11)
  * Member initialization list
  * Переприсваивание в конструкторе
* Приватные/публичные поля и методы
  * Кто к кому может обращаться в том числе не у `this`
  * Паттерн: геттеры и сеттеры для поддержания инвариантов
  * Не было: `protected`, наследование.
* Отличия `struct`/`class`.
* Агрегатная инициализация простых классов через `{}`
  * Не было: строгое определение "простого класса" и его отличия между стандартами C++11, C++14, C++17, C++20.

## Функции-члены (методы)
* Синтаксис объявления и вызова через `.` или `->`.
* Ключевое слово `this`
  * Где его можно не писать, зачем писать хоть где-то.
  * Чем метод отличается от свободной функции.
  * Захват `this` в лямбды: `[]`, `[=]`, `[&]`, `[this]`, `[*this]`.
* Ключевое слово `template` при вызове некоторых методов.
* Const correctness: ограничение доступа к полям (в том числе ссылочным и указателям) при константном `this`.
  * Когда возникает константный `this`.
  * Const qualifier и ограничения внутри такого метода.
  * Перегрузка по const qualifier, когда нужна.
* Ref qualifier `&` в терминах категорий значений, когда нужен.
  * Не было: ref qualifier `&&`.
* Определение методов внутри и снаружи класса, неявный `inline` и зачем.
* Удобство `auto foo() -> Foo` при определении методов снаружи класса.

## Статические члены класса
* Статические поля: объявление, определение, когда что необходимо и где, обращение изнутри класса и снаружи, отличие от глобальных переменных.
* Статические константы: объявления, определение, когда что нужно и где (для тривиальных и нетривиальных типов).
  * Не было: `constexpr`, `char[]`.
* Статические методы, отличие от свободных функций.
* Паттерн: статический метод как конструктор с именем.

Тесно связано с: линковка.

## Специальные методы
* Деструктор, конструктор копирования/перемещения, оператор присваивания/перемещения.
  * Когда что вызывается: разная инициализация (copy, direct), передача как аргумента, возврат из функции.
* Реализация `unique_ptr` и `shared_ptr` (без deleter и массивов).
* Правило пяти: формулировка.
  * Copy-swap-idiom превращает в правило четырёх.
* "Нарушение" правила пяти: когда деструктор может быть тривиальным, а копирование нетривиальным (list-heap и обобщение).
* Как писать специальные методы в шаблонных классах.
